name: Build Windows Release

permissions:
  contents: write

on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.setver.outputs.new_version }}
    steps:
      - name: Checkout (full)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine or bump tag and push (if dispatch)
        id: setver
        env:
          REPO: ${{ github.repository }}
          REPO_PAT: ${{ secrets.REPO_PAT }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          echo "event: $GITHUB_EVENT_NAME"
          if [ "$GITHUB_EVENT_NAME" = "workflow_dispatch" ]; then
            echo "Manual dispatch -> bumping patch version and creating tag."
            latest=$(git tag -l "v*" --sort=-v:refname | head -n 1)
            if [ -z "$latest" ]; then
              new="v1.0.0"
            else
              base=${latest#v}
              major=${base%%.*}
              rest=${base#*.}
              minor=${rest%%.*}
              patch=${rest##*.}
              patch=$((patch + 1))
              new="v$major.$minor.$patch"
            fi
            echo "New tag will be: $new"
            if [ -n "$REPO_PAT" ]; then
              AUTH_TOKEN="$REPO_PAT"
            else
              AUTH_TOKEN="$GITHUB_TOKEN"
            fi
            git config user.name "github-actions"
            git config user.email "github-actions@github.com"
            git remote set-url origin https://${AUTH_TOKEN}@github.com/${REPO}.git
            git tag "$new"
            git push origin "$new"
            echo "new_version=$new" >> $GITHUB_OUTPUT
          else
            refname=${GITHUB_REF##*/}
            echo "Release event detected, using tag: $refname"
            echo "new_version=$refname" >> $GITHUB_OUTPUT
          fi

  build-windows:
    needs: prepare
    runs-on: windows-latest
    steps:
      - name: Checkout the tag
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ needs.prepare.outputs.new_version }}

      - name: Install Qt (MinGW 8.1.0)
        uses: jurplel/install-qt-action@v3
        with:
          version: '5.15.2'
          host: 'windows'
          target: 'desktop'
          arch: 'win64_mingw81'
          install-deps: 'true'
          # ONLY install the compiler toolchain here. OpenSSL is separate.
          tools: 'tools_mingw,qt.tools.win64_mingw810'

      - name: Install OpenSSL (Manual AQT)
        shell: bash
        run: |
          # Manually install OpenSSL using aqt, which is already installed by the action above
          # We use the python environment set up by the action
          python -m aqt install-tool windows desktop tools_openssl qt.tools.openssl.win_x64 --outputdir "$Qt5_Dir/../../"
        env:
          # Use the same Qt directory structure
          Qt5_Dir: ${{ env.Qt5_Dir }}

      - name: Build and Package (MinGW)
        shell: bash
        env:
          QT_ROOT: ${{ env.Qt5_Dir }}
          MINGW_BIN: ${{ env.IQTA_TOOLS }}/mingw810_64/bin
        run: |
          set -e
          echo "Qt5_Dir = ${Qt5_Dir}"
          echo "IQTA_TOOLS = ${IQTA_TOOLS}"
          
          # We need to find where the manual step installed OpenSSL
          # It usually goes to D:\a\NoveoCPP\Qt\Tools\OpenSSL\Win_x64
          # We'll search for it dynamically to be safe.
          OPENSSL_ROOT=$(find "${Qt5_Dir}/../../Tools" -type d -name "OpenSSL" | head -n 1)
          echo "Found OpenSSL Root: $OPENSSL_ROOT"

          export QT_ROOT="${Qt5_Dir}"
          export MINGW_BIN="${IQTA_TOOLS}/mingw810_64/bin"
          export PATH="$MINGW_BIN:$QT_ROOT/bin:$PATH"
          export QT_PLUGIN_PATH="${QT_ROOT}/plugins"

          mkdir -p build
          cd build

          echo "Configuring project..."
          cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release
          echo "Building..."
          cmake --build . --config Release

          echo "Running windeployqt..."
          "$QT_ROOT/bin/windeployqt.exe" --release --no-translations --no-compiler-runtime --dir . ./NoveoDesktop.exe || true

          # --- FIX START: Copy OpenSSL DLLs ---
          echo "Copying OpenSSL DLLs..."
          
          # Search in the OpenSSL tool directory we just installed
          if [ -d "$OPENSSL_ROOT" ]; then
             find "$OPENSSL_ROOT" -name "libssl-1_1-x64.dll" -exec cp {} . \;
             find "$OPENSSL_ROOT" -name "libcrypto-1_1-x64.dll" -exec cp {} . \;
             
             # Also try standard names if x64 variants aren't found
             if [ ! -f "libssl-1_1-x64.dll" ]; then
                find "$OPENSSL_ROOT" -name "libssl-1_1.dll" -exec cp {} . \;
                find "$OPENSSL_ROOT" -name "libcrypto-1_1.dll" -exec cp {} . \;
             fi
          else
             echo "ERROR: OpenSSL directory not found!"
             exit 1
          fi

          if [ ! -f "libssl-1_1-x64.dll" ] && [ ! -f "libssl-1_1.dll" ]; then
              echo "ERROR: Could not find OpenSSL DLLs to copy."
              exit 1
          fi
          # --- FIX END ---

          # Fallback: ensure core Qt DLLs are present
          for dll in Qt5Core.dll Qt5Gui.dll Qt5Network.dll Qt5WebSockets.dll Qt5Widgets.dll; do
            if [ ! -f "$dll" ]; then
              if [ -f "$QT_ROOT/bin/$dll" ]; then
                echo "Copying $dll from Qt bin"
                cp "$QT_ROOT/bin/$dll" .
              fi
            fi
          done

          # Ensure platform plugin
          if [ ! -d "platforms" ] || [ ! -f "platforms/qwindows.dll" ]; then
            mkdir -p platforms
            if [ -f "$QT_ROOT/plugins/platforms/qwindows.dll" ]; then
              cp "$QT_ROOT/plugins/platforms/qwindows.dll" platforms/
            fi
          fi

          # Copy MinGW runtimes
          cp "$MINGW_BIN/libgcc_s_seh-1.dll" . || true
          cp "$MINGW_BIN/libstdc++-6.dll" . || true
          cp "$MINGW_BIN/libwinpthread-1.dll" . || true

          VERSION=${{ needs.prepare.outputs.new_version }}
          ZIP_NAME="NoveoDesktop-${VERSION}.zip"

          echo "Creating ZIP: $ZIP_NAME"
          7z a "$ZIP_NAME" * -xr!*.obj -xr!*.cpp -xr!*.h -xr!Makefile -xr!CMakeFiles -xr!*_autogen

      - name: Upload ZIP to Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.prepare.outputs.new_version }}
          name: "NoveoDesktop Windows Release - ${{ needs.prepare.outputs.new_version }}"
          files: build/NoveoDesktop-${{ needs.prepare.outputs.new_version }}.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: NoveoDesktop-Windows-${{ needs.prepare.outputs.new_version }}
          path: build/NoveoDesktop-${{ needs.prepare.outputs.new_version }}.zip
